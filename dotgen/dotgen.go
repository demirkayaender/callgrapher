package main

import (
	"fmt"
	"sort"
	"strings"
)

// DOTGenerator generates DOT format callgraphs
type DOTGenerator struct {
	callGraph *CallGraph
	maxDepth  int
}

// NewDOTGenerator creates a new DOT generator
func NewDOTGenerator(cg *CallGraph, maxDepth int) *DOTGenerator {
	return &DOTGenerator{
		callGraph: cg,
		maxDepth:  maxDepth,
	}
}

// Generate creates the DOT file content
func (g *DOTGenerator) Generate() string {
	var sb strings.Builder

	// Header
	sb.WriteString("digraph callgraph {\n")
	sb.WriteString("    // Generated by dotgen - Go Callgraph Generator\n")
	sb.WriteString("    // https://github.com/callgraph/dotgen\n\n")
	
	// Graph attributes
	sb.WriteString("    // Graph layout\n")
	sb.WriteString("    rankdir=TB;\n")
	sb.WriteString("    node [shape=box, style=rounded, fontname=\"Arial\"];\n")
	sb.WriteString("    edge [fontname=\"Arial\", fontsize=10];\n\n")

	// Group by package
	packages := g.groupByPackage()
	packageColors := g.assignPackageColors(packages)

	// Generate nodes
	sb.WriteString("    // Nodes (Functions)\n")
	funcNames := make([]string, 0, len(g.callGraph.Functions))
	for name := range g.callGraph.Functions {
		funcNames = append(funcNames, name)
	}
	sort.Strings(funcNames)

	for _, fullName := range funcNames {
		fn := g.callGraph.Functions[fullName]
		sb.WriteString(g.generateNode(fullName, fn, packageColors[fn.Package]))
	}

	sb.WriteString("\n")

	// Generate edges
	sb.WriteString("    // Edges (Function Calls)\n")
	
	// Remove duplicate calls
	uniqueCalls := g.deduplicateCalls()
	
	// Sort for consistent output
	sort.Slice(uniqueCalls, func(i, j int) bool {
		if uniqueCalls[i].From == uniqueCalls[j].From {
			return uniqueCalls[i].To < uniqueCalls[j].To
		}
		return uniqueCalls[i].From < uniqueCalls[j].From
	})

	for _, call := range uniqueCalls {
		// Only include calls between known functions
		if _, exists := g.callGraph.Functions[call.From]; exists {
			if _, exists := g.callGraph.Functions[call.To]; exists {
				sb.WriteString(fmt.Sprintf("    \"%s\" -> \"%s\";\n", 
					g.escapeLabel(call.From), 
					g.escapeLabel(call.To)))
			}
		}
	}

	// Subgraphs for packages (optional clustering)
	if len(packages) > 1 && len(packages) < 20 {
		sb.WriteString("\n    // Package clusters\n")
		for i, pkgName := range g.getSortedPackages(packages) {
			funcs := packages[pkgName]
			if len(funcs) > 1 {
				sb.WriteString(fmt.Sprintf("    subgraph cluster_%d {\n", i))
				sb.WriteString(fmt.Sprintf("        label=\"%s\";\n", pkgName))
				sb.WriteString("        style=dashed;\n")
				sb.WriteString(fmt.Sprintf("        color=\"%s\";\n", packageColors[pkgName]))
				
				for _, fn := range funcs {
					sb.WriteString(fmt.Sprintf("        \"%s\";\n", g.escapeLabel(fn)))
				}
				
				sb.WriteString("    }\n")
			}
		}
	}

	sb.WriteString("}\n")

	return sb.String()
}

// generateNode creates a DOT node definition
func (g *DOTGenerator) generateNode(fullName string, fn *Function, color string) string {
	label := g.createNodeLabel(fn)
	style := "filled"
	fillColor := color
	
	if fn.IsExported {
		// Exported functions are more prominent
		style = "filled,bold"
	}

	return fmt.Sprintf("    \"%s\" [label=\"%s\", style=\"%s\", fillcolor=\"%s\"];\n",
		g.escapeLabel(fullName),
		label,
		style,
		fillColor)
}

// createNodeLabel creates a readable label for a function
func (g *DOTGenerator) createNodeLabel(fn *Function) string {
	if fn.Receiver != "" {
		// Method: show as Receiver.Method
		return fmt.Sprintf("%s.%s()", fn.Receiver, fn.Name)
	}
	// Function: show as Function
	return fmt.Sprintf("%s()", fn.Name)
}

// groupByPackage groups functions by their package
func (g *DOTGenerator) groupByPackage() map[string][]string {
	packages := make(map[string][]string)
	
	for fullName, fn := range g.callGraph.Functions {
		packages[fn.Package] = append(packages[fn.Package], fullName)
	}
	
	return packages
}

// getSortedPackages returns package names in sorted order
func (g *DOTGenerator) getSortedPackages(packages map[string][]string) []string {
	names := make([]string, 0, len(packages))
	for name := range packages {
		names = append(names, name)
	}
	sort.Strings(names)
	return names
}

// assignPackageColors assigns colors to packages
func (g *DOTGenerator) assignPackageColors(packages map[string][]string) map[string]string {
	colors := []string{
		"lightblue",
		"lightgreen",
		"lightyellow",
		"lightpink",
		"lightcyan",
		"lightgoldenrod",
		"lavender",
		"mistyrose",
		"honeydew",
		"azure",
	}
	
	colorMap := make(map[string]string)
	pkgNames := g.getSortedPackages(packages)
	
	for i, pkgName := range pkgNames {
		colorMap[pkgName] = colors[i%len(colors)]
	}
	
	return colorMap
}

// deduplicateCalls removes duplicate calls
func (g *DOTGenerator) deduplicateCalls() []Call {
	seen := make(map[string]bool)
	unique := make([]Call, 0)
	
	for _, call := range g.callGraph.Calls {
		key := call.From + "->" + call.To
		if !seen[key] {
			seen[key] = true
			unique = append(unique, call)
		}
	}
	
	return unique
}

// escapeLabel escapes special characters in DOT labels
func (g *DOTGenerator) escapeLabel(label string) string {
	label = strings.ReplaceAll(label, "\\", "\\\\")
	label = strings.ReplaceAll(label, "\"", "\\\"")
	label = strings.ReplaceAll(label, "\n", "\\n")
	return label
}

